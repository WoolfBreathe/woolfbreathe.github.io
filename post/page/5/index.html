<!DOCTYPE html>
<html lang="zh">
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">


  <title>Posts-WoolfBreathe</title>
  <meta property="og:title" content="Posts" />
  <meta name="twitter:title" content="Posts" />

  <meta name="author" content="WoolfBreathe"/>
  <link href="/img/favicon.png" rel="icon" type="image/x-icon" />
  <link rel="apple-touch-icon" href="/img/favicon.png"/>
  <meta property="og:image" content="/img/avatar-icon.png" />
  <meta name="twitter:image" content="/img/avatar-icon.png" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@username" />
  <meta name="twitter:creator" content="@username" />
  <meta property="og:url" content="/" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="WoolfBreathe" />

  <meta name="generator" content="Hugo 0.68.3" />
  <link rel="canonical" href="/" />
  <link rel="alternate" href="/index.xml" type="application/rss+xml" title="WoolfBreathe">

  
  
  <link href="https://fonts.googleapis.com/css?family=Lora:400,400i,700%7COpen+Sans:400,700" rel="stylesheet">
  

  <link rel="stylesheet" href='/css/bundle.min.62de9d30b83723e0d55f82908aedb1c5eb18c910bc24bcf43e530ce754ee1502.css' integrity='sha256-Yt6dMLg3I&#43;DVX4KQiu2xxesYyRC8JLz0PlMM51TuFQI='>

  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/slick-carousel@1.8.1/slick/slick.css"/>
  
  
    
    <!--[if lt IE 9]>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <![endif]-->
<meta name="google-site-verification" content="oKxX4fOvB2yYmU02txZFChM93XQbESU4JaG3tNH9Hm8" />
<meta name="baidu-site-verification" content="F5ojAyqaKU" />
<meta name="keywords" content="">




</head>

  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">切换导航</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/" title="WoolfBreathe">
        <img src="/img/avatar-icon.png" style="margin-top: -5px;height: 32px;" alt="WoolfBreathe">
      </a>
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        
          
            <li>
              <a title="首页" href="/">首页</a>
            </li>
          
        
          
            <li>
              <a title="归档" href="/archives">归档</a>
            </li>
          
        
          
            <li>
              <a title="标签" href="/tags">标签</a>
            </li>
          
        
          
            <li>
              <a title="关于" href="/page/about/">关于</a>
            </li>
          
        
          
            <li>
              <a title="RSS" href="/index.xml">RSS</a>
            </li>
          
        

        

        

        
          <li>
            <a href="#modalSearch" data-toggle="modal" data-target="#modalSearch" style="outline: none;">
              <span id="searchGlyph" class="glyphicon glyphicon-search"></span>
            </a>
          </li>
          

      </ul>
    </div>

  </div>
</nav>


  <div id="modalSearch" class="modal fade" role="dialog">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <button type="button" class="close" data-dismiss="modal">&times;</button>
          <h4 class="modal-title">搜索</h4>
        </div>
        <div class="modal-body">
            
<div class="aa-input-container" id="aa-input-container">
    <input type="search" id="aa-search-input" class="aa-input-search" placeholder="Search for titles or URIs..." name="search" autocomplete="off" />
    <svg class="aa-input-icon" viewBox="654 -372 1664 1664">
        <path d="M1806,332c0-123.3-43.8-228.8-131.5-316.5C1586.8-72.2,1481.3-116,1358-116s-228.8,43.8-316.5,131.5  C953.8,103.2,910,208.7,910,332s43.8,228.8,131.5,316.5C1129.2,736.2,1234.7,780,1358,780s228.8-43.8,316.5-131.5  C1762.2,560.8,1806,455.3,1806,332z M2318,1164c0,34.7-12.7,64.7-38,90s-55.3,38-90,38c-36,0-66-12.7-90-38l-343-342  c-119.3,82.7-252.3,124-399,124c-95.3,0-186.5-18.5-273.5-55.5s-162-87-225-150s-113-138-150-225S654,427.3,654,332  s18.5-186.5,55.5-273.5s87-162,150-225s138-113,225-150S1262.7-372,1358-372s186.5,18.5,273.5,55.5s162,87,225,150s113,138,150,225  S2062,236.7,2062,332c0,146.7-41.3,279.7-124,399l343,343C2305.7,1098.7,2318,1128.7,2318,1164z" />
    </svg>
</div>
<script src="/js/algoliasearch.min.js"></script>
<script src="/js/autocomplete.min.js"></script>

<script>
var client = algoliasearch("1JDRAS0AZR", "8804ac109158bb3bb60d74ce98fa332f");
var index = client.initIndex('prod_blog');

autocomplete('#aa-search-input',
{ hint: false}, {
    source: autocomplete.sources.hits(index, {hitsPerPage: 5}),
    
    displayKey: 'name',
    
    templates: {
        
        suggestion: function(suggestion) {
            return '<span>' + '<a href="/post/' + suggestion.slug + '">' +
            suggestion._highlightResult.title.value + '</a></span>';
        }
    }
});
</script>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-default" data-dismiss="modal">close</button>
        </div>
      </div>
    </div>
  </div>

    
  <header class="header-section ">
    <div class="intro-header no-img">
      <div class="container">
        <div class="row">
          <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            <div class="page-heading">
              <h1>Posts</h1>
              <hr class="small">
            </div>
          </div>
        </div>
      </div>
    </div>
  </header>

    
  <div class="container" role="main">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        
        <div class="posts-list">
          
            <article class="post-preview">
              <a href="/post/algorithms/stringmatching/algorithms-stringmatching-bf/">
                <h2 class="post-title">字符串匹配-BF(暴力匹配算法)</h2>

                
              </a>

              <p class="post-meta">
                发表于 map[Count:2019-08-17]
              </p>
              <div class="post-entry">
                
                  <h1 id="原理">原理</h1>
<p>最简单的字符串匹配算法 —— BF 算法说起，BF 是 Brute Force 的缩写，中文译作暴力匹配算法，也叫朴素匹配算法。</p>
<p>BF 算法的原理很简单，在继续介绍之前，我们先引入两个术语：主串和模式串。简单来说，我们要在字符串 A 中查找子串 B，那么 A 就是主串，B 就是模式串。</p>
<p>作为最简单、最暴力的字符串匹配算法，BF 算法的思想可以用一句话来概括，那就是，如果主串长度为 n，模式串长度为 m，我们在主串中检查起始位置分别是 0、1、2…n-m 且长度为 m 的 n-m+1 个子串，看有没有跟模式串匹配的。图示如下：</p>
<p><img src="/img/posts/AlgorithmsAndDataStructures/StringMatching/1b463b1483d77731af561b5748d5eefa9568c11566c3f54624771e6f2c2ab128.png" alt="BF算法图示"></p>
<p>结合上图，具体来说，就是每次拿模式串和主串对齐，然后从左到右依次比较每个字符，如果出现不相等，则把模式串往后移一个位置，再次重复上述步骤，直到模式串每个字符与对应主串位置字符都相等，则返回主串对应下标，表示找到，否则返回 -1，表示没找到。</p>
<p>这个算法很好理解，因为这就是我们正常都能想到的暴力匹配，BF 算法的时间复杂度最差是 O(n*m)，意味着要模式串要移到主串 n-m 的位置上，并且模式串每个字符都要与子串比较。</p>
<p>尽管 BF 算法复杂度看起来很高，但是在日常开发中，如果主串和模式串规模不大的话，该算法依然比较常用，因为足够简单，实现起来容易，不容易出错。另外，在规模不大的情况下，开销也可以接受，毕竟 O(n*m) 是最差的表现，大部分时候，执行效率比这个都要高。</p>
<p>但是对于对时间要求比较敏感，或者需要高频匹配，数据规模较大的情况下，比如编辑器中的匹配功能、敏感词匹配系统等，BF 算法就不适用了。</p>

                
              </div>

              
                <span class="post-meta">
                  
                    #<a href="/tags/algorithms/">Algorithms</a>&nbsp;
                  
                    #<a href="/tags/stringmatching/">StringMatching</a>&nbsp;
                  
                </span>
              

            </article>
          
            <article class="post-preview">
              <a href="/post/algorithms/datastructures/algorithms-datastructures-hashtable/">
                <h2 class="post-title">数据结构-散列表(HashTable, 哈希表)</h2>

                
              </a>

              <p class="post-meta">
                发表于 map[Count:2019-08-16]
              </p>
              <div class="post-entry">
                
                  散列表(HashTable, 哈希表) 散列表（HashTable，也叫哈希表），是根据键（Key）直接访问在内存存储位置的数据结构。
其实现原理是：通过散列函数（也叫哈希函数）将元素的键映射为数组下标（转化后的值叫做散列值或哈希值），然后在对应下标位置存储记录值。按照键值查询元素时，就是用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据：
散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。而 PHP 的关联数组干脆就是基于散列表实现。
散列技术既是一种存储方法，也是一种查找方法。与之前的查找方法不同的是散列技术的记录之间不存在逻辑关系，因此主要是面向查找的数据结构。最适合求解的问题是查找给定值相等的记录。
散列表中有两个关键的概念，一个是散列函数（或者哈希函数），一个是散列冲突（或者哈希冲突）。
散列函数 散列函数用于将键值经过处理后转化为散列值。具有以下特性：
散列函数计算得到的散列值是非负整数 如果 key1 == key2，则 hash(key1) == hash(key2) 如果 key1 != key2，则 hash(key1) != hash(key2)  散列冲突 所谓散列冲突，简单来说，指的是 key1 != key2 的情况下，通过散列函数处理，hash(key1) == hash(key2)，这个时候，发生了散列冲突。设计再好的散列函数也无法避免散列冲突，原因是散列值是非负整数，总量是有限的，但是现实世界中要处理的键值是无限的，将无限的数据映射到有限的集合，肯定避免不了冲突。
事实上，如果不考虑散列冲突，散列表的查找效率是非常高的，时间复杂度是 O(1)，比二分查找效率还要高，但是因为无法避免散列冲突，所以散列表查找的时间复杂度取决于散列冲突，最坏的情况可能是 O(n)，退化为顺序查找。这种情况在散列函数设计不合理的情况下更糟。
散列函数设计 $arr[&lsquo;test&rsquo;] = 123 这段代码，PHP 底层会将键值 test 通过散列函数转化为散列码，然后将 123 映射到这个散列码上。在不考虑哈希冲突的情况下，散列表查找、删除、插入的时间复杂度都是 O(1)，非常高效。
要减少哈希冲突，提高散列表操作效率，设计一个优秀的散列函数至关重要，平时经常使用的 md5 函数就是一个散列函数，但是其实还有其他很多自定义的设计实现，要根据不同场景，设计不同的散列函数来减少散列冲突，而且散列函数本身也要很简单，否则执行散列函数本身会成为散列表的瓶颈。日常很少会自己去设计散列函数，但是做一些简单的了解还是有必要的。
通常有以下几种散列函数构造方法：
直接定址法：即 f(key) = a*key + b，f 表示散列函数，a、b 是常量，key 是键值 数字分析法：即对数字做左移、右移、反转等操作获取散列值 除数留余法：即 f(key) = key % p，p 表示容器数量，这种方式通常用在将数据存放到指定容器中，如何决定哪个数据放到哪个容器，比如分表后插入数据如何处理（此时 p 表示拆分后数据表的数量），分布式 Redis 如何存放数据（此时 p 表示几台 Redis 服务器） 随机数法：即 f(key) = random(key)，比如负载均衡的 random 机制  以上只是一些比较场景的散列函数设计思路，还有很多其他的设计方法，这里就不一一列举了。
                  <a href="/post/algorithms/datastructures/algorithms-datastructures-hashtable/" class="post-read-more">[阅读全文]</a>
                
              </div>

              
                <span class="post-meta">
                  
                    #<a href="/tags/algorithms/">Algorithms</a>&nbsp;
                  
                </span>
              

            </article>
          
            <article class="post-preview">
              <a href="/post/algorithms/binarysearch/algorithms-binarysearch-case/">
                <h2 class="post-title">二分查找(BinarySearch)-索引查找</h2>

                
              </a>

              <p class="post-meta">
                发表于 map[Count:2019-08-15]
              </p>
              <div class="post-entry">
                
                  IP 地址对应城市查询 每个城市都有对应的 IP 地址段，这个在网上搜一下就能拿到。然后可以将这些不同城市 IP 地址段起始值转化为整型数字（转化函数Google/百度搜下就能找到），进而对其进行排序，就可以得到一个有序的序列。比如杭州和北京，IP区间分别是 [183.128.0.0,183.159.255.255] 和 [110.96.0.0,110.127.255.255]，转化为数字后对应区间分别是 [3078619136,3080716287] 和 [1851785216,1853882367]，这样，就可以对这两个区间起始值排序为 [1851785216,3078619136]。
此外我们还需要存储每个区间值对应的城市，以便找到对应位置后可以快速定位对应城市，可以把这个映射关系存储到数据库里面，存储字段包括城市、起始 IP、结束 IP，这里有一个前提是不同城市区间值不可能交叉，否则没法玩。
接下来就是二分查找排上用场的时候了，将待查找 IP 转化为数字，然后在排序序列中查找最后一个起始 IP 小于等于待查找 IP 的位置，通过该起始 IP 在数据库中定位到对应记录，判断待查找 IP 是否在这个 IP 区间范围内，如果在的话则返回对应城市，不在的话，就返回没找到。
稠密索引（数据库索引技术基础） 二分查找适用于有序线性表的查找，此外针对二分查找还有升级版的插值查找，以及利用斐波那契原理进行查找的斐波那契查找.
二分查找不适用于高速增长的海量数据，因为维护这个排序非常麻烦，所以我们引出索引这种数据结构。
索引是为了加快查找速度而设计的一种数据结构。索引就是把一个关键字与它对应的记录相关联的过程，一个索引由若干索引项构成，每个索引项至少包含关键字和其对应记录在存储器中的位置等信息。
由此可见，索引技术是组织大型数据库和磁盘文件的一种重要技术。
索引技术分为线性索引、树形索引和多级索引，这里我们只介绍线性索引。所谓线性索引就是将索引项集合组织为线性结构，也称索引表。以下是一个索引表的示例图：
在线性索引中，我们重点介绍三种：稠密索引、分块索引和倒排索引。
首先是稠密索引。稠密索引是指在线性表中，将数据集中的每个记录对应一个索引项。就像上面示例图中的那样。以主键为例，可以将其抽象化如下：
对于稠密索引这个索引表来说，索引项一定按照关键码有序排列，这样可以应用二分查找，以免索引查找本身影响性能。可见，稠密索引性能可以做到和二分查找相当（找到对应关键码就可以通过指针直接指向对应记录），但是索引项长度和数据集一样长，空间复杂度高，如果数据太多需要存放到磁盘上，反复读取磁盘对性能影响很大。
分块索引（数据库索引技术基础） 为了减少索引项个数，对数据集进行分块，并使其分块有序，然后再给每个分块建立一个索引项（索引值是分块中最大关键码），至于分块内部，则不管其有序性，从而减少索引项的个数。在查找的时候在索引项中通过二分查找找到指定索引项，然后根据该索引项中的关键码去相应分块遍历查找指定元素，这是一种折中方案，既兼顾了空间复杂度，又兼顾了时间复杂度。
分块索引图示如下：
这里面有几个概念需要阐述下，首先是分块有序，需要满足两个先决条件：
块内无序。即每一块内的记录不要求有序。当然，有序更理想，只不过要花费大量时间和空间的代价。 块间有序。即要求后一块的所有关键字都大于前一块的所有关键字。只有块间有序，才能给查找带来效率。  其次，分块索引的索引项包含三个数据项：
最大关键码：它存储每一块中的最大关键字。这样做的好处是在它之后的下一块中最小的关键字也能比这一块最大的关键字要大。 块长：存储块中的记录个数，以便于循环时使用。 块首指针：用于指向块首数据元素的指针，便于开始对这一块的记录开始遍历。  最后，在分块索引中查找，分两块进行：
在分块索引表中查找要查找关键字所在的块。由于块间有序，所以可以通过二分查找快速定位（通过不小于给定值的第一个元素，不大于给定值的最后一个元素确定区间，以前面给出的示例图为例，58位于57和96之间，则会去第三块中查找）。 根据块首指针找到相应的块，并在块中顺序查找指定值（即关键码，块中无序所以只能顺序查找）。  分块索引的时间复杂度是：O(log(m)+n)，其中 m 是分块数，n 是块内元素个数，在索引表长度和块内元素相等时，时间复杂度最优。性能要优于顺序查找，但是比二分查找要差。
总体来说，分块索引在兼顾存储空间和查找性能的情况下，被普遍用于数据库查找等技术中。
倒排索引（搜素引擎技术基础） 百度、Google 等搜索引擎为我们日常查找信息带来了巨大的方便，你是否思考过搜索引擎是如何从海量 HTML 文档中通过关键词查找资源的？今天给大家介绍最简单，也是最基础的搜索引擎技术 —— 倒排索引。
有倒排索引，就有正向索引，正向索引指的是通过文档 ID 找到对应的文档，如果通过文档ID查找对应文档，再在文档中匹配关键词，意味着要扫描所有文档，最后还要排序，对于互联网上的海量资源来说，显然是不可取的。
                  <a href="/post/algorithms/binarysearch/algorithms-binarysearch-case/" class="post-read-more">[阅读全文]</a>
                
              </div>

              
                <span class="post-meta">
                  
                    #<a href="/tags/algorithms/">Algorithms</a>&nbsp;
                  
                    #<a href="/tags/binarysearch/">BinarySearch</a>&nbsp;
                  
                </span>
              

            </article>
          
            <article class="post-preview">
              <a href="/post/algorithms/binarysearch/algorithms-binarysearch-interval/">
                <h2 class="post-title">二分查找(BinarySearch)-区间查找</h2>

                
              </a>

              <p class="post-meta">
                发表于 map[Count:2019-08-14]
              </p>
              <div class="post-entry">
                
                  实现原理 二分查找的第三个变形版本：在给定排序序列中查找第一个大于等于给定值的元素。
有了昨天的基础，来解决今天这个问题，是不是很简单？所不同的是判断节点不一样了，我们之前的需求都是查找等于给定值，现在变成了大于等于给定值，所以我们要在 $nums[$mid] &gt;= $num 这个判断条件上做文章，思路还是和之前两个变形版本类似，当 $mid 已经是最左边的元素，或者 $mid 的前一个元素值小于给定查询值，则 $mid 对应元素即为满足条件的元素，否则继续往前查找。
示例代码 对应的 PHP 实现代码如下：
&lt;?php /** * 二分查找变形版：查找第一个大于等于给定值的元素（数组中包含重复数据） */ function binary_search($nums, $num) { if (count($nums) &lt;= 1) { return 0; } return binary_search_internal($nums, $num, 0, count($nums) - 1); } function binary_search_internal($nums, $num, $low, $high) { if ($low &gt; $high) { return -1; } $mid = floor(($low + $high) / 2); if ($num &lt;= $nums[$mid]) { if ($mid == 0 || $nums[$mid - 1] &lt; $num) { return $mid; } else { return binary_search_internal($nums, $num, $low, $mid - 1); } } elseif ($num &gt; $nums[$mid]) { return binary_search_internal($nums, $num, $mid + 1, $high); } } $nums = [1, 2, 3, 3, 4, 5, 6]; $index = binary_search($nums, 3); print $index; 同样，与之相对的，还有我们这次分享中最后要讨论的一个二分查找的变形版本：在给定序列中查找最后一个小于等于给定值的元素。
                  <a href="/post/algorithms/binarysearch/algorithms-binarysearch-interval/" class="post-read-more">[阅读全文]</a>
                
              </div>

              
                <span class="post-meta">
                  
                    #<a href="/tags/algorithms/">Algorithms</a>&nbsp;
                  
                    #<a href="/tags/binarysearch/">BinarySearch</a>&nbsp;
                  
                </span>
              

            </article>
          
            <article class="post-preview">
              <a href="/post/algorithms/binarysearch/algorithms-binarysearch-repeat/">
                <h2 class="post-title">二分查找(BinarySearch)-数组含有重复值</h2>

                
              </a>

              <p class="post-meta">
                发表于 map[Count:2019-08-13]
              </p>
              <div class="post-entry">
                
                  日常开发过程中，除了正常的二分查找，还有很多二分查找的变形版本。
符合标准的二分查找条件的序列一般是比较理想的情况，如果要查找的元素在序列中有多个怎么办？所以第一个常见的变形版本，就是在一个给定排序序列中查找第一个等于给定值的元素。
其实关键节点就在于在序列中找到值等于待查找元素值时的处理。如果此时 $mid 位置已经到了序列的最左边，不能再往左了，或者序列中索引小于 $mid 的上一个元素值不等于待查找元素值，那么此时 $mid 就是第一个等于待查找元素值的位置；否则还要继续往前找。
对应的 PHP 实现代码如下，其他地方都一样，就是 $num == $nums[$mid] 时的处理逻辑变了：
&lt;?php /** * 二分查找变形版：查找第一个值等于给定值的元素（数组中包含重复数据） */ function binary_search($nums, $num) { if (count($nums) &lt;= 1) { return 0; } return binary_search_internal($nums, $num, 0, count($nums) - 1); } function binary_search_internal($nums, $num, $low, $high) { if ($low &gt; $high) { return -1; } $mid = floor(($low + $high) / 2); if ($num &lt; $nums[$mid]) { return binary_search_internal($nums, $num, $low, $mid - 1); } elseif ($num &gt; $nums[$mid]) { return binary_search_internal($nums, $num, $mid + 1, $high); } else { if ($mid == 0 || $nums[$mid-1] !
                  <a href="/post/algorithms/binarysearch/algorithms-binarysearch-repeat/" class="post-read-more">[阅读全文]</a>
                
              </div>

              
                <span class="post-meta">
                  
                    #<a href="/tags/algorithms/">Algorithms</a>&nbsp;
                  
                    #<a href="/tags/binarysearch/">BinarySearch</a>&nbsp;
                  
                </span>
              

            </article>
          
            <article class="post-preview">
              <a href="/post/algorithms/binarysearch/algorithms-binarysearch-base/">
                <h2 class="post-title">二分查找(BinarySearch)</h2>

                
              </a>

              <p class="post-meta">
                发表于 map[Count:2019-08-12]
              </p>
              <div class="post-entry">
                
                  二分查找(BinarySearch) 在介绍二分查找之前，对于基于数字索引的数组元素的查找，第一反应都是遍历这个数组，直到给定数组元素值和待查找的值相等时，返回索引值并退出，否则一直遍历到最后一个元素，如果还是没有找到则返回 -1，这样的查找虽然是简单粗暴了点，但是对于规模不大的数据集，也是没什么问题的，不过很明显，对于 n 个元素的数组，这种查找的时间复杂度是 O(n)，随着数据规模的增加，性能会越来越差，设想如果数据集的长度是 40 亿（约 2 的 32 次方），那么最差的情况需要遍历数组 40 亿次，简直不敢想象需要花费多长时间！那有没有性能搞好的算法来解决这个问题呢？
在进一步探讨这个问题之前，先来看一个生活中的例子。日常生活中，很多人应该有这种经历，朋友、同学或者同事淘了个宝贝，神秘兮兮的过来让大家猜多少钱，在约定一个价格范围之后（比如 10-100），大家会七嘴八舌的猜起价格来：
同事A：新淘了个宝贝，猜猜多少钱？ 同事B：50块。 同事A：高了。 同事C：30块。 同事A：低了。 同事D：40块。 同事A：高了。 同事E：36块。 同事A：对了。  如果用顺序遍历的逻辑，最差需要 91 次，才能猜到价格，现实生活中，没人会这么干，我们采用上面这种逻辑，只需要 4 次就猜到价格了，快了几十倍，而且数据量越大，优势越明显。基于这种思路，我算法科学家提炼出了二分查找算法，帮助在给定数据集中快速定位要查找的元素。
实现原理 所谓二分查找，针对的是一个有序的数据集合（这点很重要），查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。注意到二分查找针对的必须是已经排序过的有序数组，否则不能使用该算法。图示如下：
示例代码 思路比较简单，我们将其通过 PHP 代码实现如下：
&lt;?php function binary_search($nums, $num) { return binary_search_internal($nums, $num, 0, count($nums) - 1); } function binary_search_internal($nums, $num, $low, $high) { if ($low &gt; $high) { return -1; } $mid = floor(($low + $high) / 2); if ($num &gt; $nums[$mid]) { return binary_search_internal($nums, $num, $mid + 1, $high); } elseif ($num &lt; $nums[$mid]) { return binary_search_internal($nums, $num, $low, $mid - 1); } else { return $mid; } } $nums = [1, 2, 3, 4, 5, 6]; $index = binary_search($nums, 5); print $index; 性能分析 很显然，二分查找的时间复杂度是 O(logn)。这是一个非常恐怖的数量级，有时候甚至比 O(1) 还要高效，比如要在开头提到的 40 亿个数字中查找某一个元素，也只需要32次（2 的 32 次方是 40 亿数量级），这真的是非常高效了，正因如此二分查找在线性表结构中的应用非常广泛。
                  <a href="/post/algorithms/binarysearch/algorithms-binarysearch-base/" class="post-read-more">[阅读全文]</a>
                
              </div>

              
                <span class="post-meta">
                  
                    #<a href="/tags/algorithms/">Algorithms</a>&nbsp;
                  
                    #<a href="/tags/binarysearch/">BinarySearch</a>&nbsp;
                  
                </span>
              

            </article>
          
            <article class="post-preview">
              <a href="/post/algorithms/sort/algorithms-sort-selectionsort/">
                <h2 class="post-title">排序算法-选择排序(SelectionSort)</h2>

                
              </a>

              <p class="post-meta">
                发表于 map[Count:2019-08-09]
              </p>
              <div class="post-entry">
                
                  实现原理 选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。图示如下： 光看定义有点抽象，用图来演示，假设待排序数字是 4、5、6、3、2、1，第一次排序的流程是这样的：
在这里搭配动态图查看效果更佳：https://visualgo.net/zh/sorting。
&lt;?php /** * 选择排序算法实现 */ function selection_sort($nums) { if (count($nums) &lt;= 1) { return $nums; } for ($i = 0; $i &lt; count($nums); $i++) { $min= $i; for ($j = $i + 1; $j &lt; count($nums); $j++) { if ($nums[$j] &lt; $nums[$min]) { $min = $j; } } if ($min != $i) { $temp = $nums[$i]; $nums[$i] = $nums[$min]; $nums[$min] = $temp; } } return $nums; } $nums = [4, 5, 6, 3, 2, 1]; $nums = selection_sort($nums); print_r($nums); 性能分析 很显然，选择排序的时间复杂度也是 O(n2) 由于不涉及额外的存储空间，所以是原地排序； 由于涉及非相邻元素的位置交换，所以是不稳定的排序算法。  综合比较前面介绍的三个排序算法，时间复杂度都是一样的，也都是原地排序，但是选择排序是不稳定的排序算法，此外，插入排序和冒泡排序相比较，在将插入排序的时候讲到，插入排序只需要一条语句，而冒泡排序需要三条，在同等条件下，或者数据量很大的情况下，插入排序性能是要优于冒泡排序的，所以综合比较下来，三者的优先级是插入排序 &gt; 冒泡排序 &raquo; 选择排序。
                  <a href="/post/algorithms/sort/algorithms-sort-selectionsort/" class="post-read-more">[阅读全文]</a>
                
              </div>

              
                <span class="post-meta">
                  
                    #<a href="/tags/algorithms/">Algorithms</a>&nbsp;
                  
                </span>
              

            </article>
          
            <article class="post-preview">
              <a href="/post/algorithms/sort/algorithms-sort-insertionsort/">
                <h2 class="post-title">排序算法-选择排序(InsertionSort)</h2>

                
              </a>

              <p class="post-meta">
                发表于 map[Count:2019-08-08]
              </p>
              <div class="post-entry">
                
                  <h1 id="实现原理">实现原理</h1>
<p>插入排序的原理是：将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。</p>
<p>光看定义有点抽象，用图来演示，假设待排序数字是 4、5、6、3、2、1，第一次排序的流程是这样的：</p>
<p><img src="/img/posts/AlgorithmsAndDataStructures/InsertionSort/Fp2wlQjdiEtuhI9MQaYSqM17Q40G.png" alt="插入排序"></p>
<p>在这里搭配动态图查看效果更佳：https://visualgo.net/zh/sorting。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">&lt;?php
    
    /**
     * 插入排序实现函数（PHP）
     * @param $nums
     * @return mixed
     */
    function insertion_sort($nums) {
        if (count($nums) &lt;= 1) {
            return $nums;
        }
    
        for ($i = 0; $i &lt; count($nums); $i++) {
            $value = $nums[$i];
            $j = $i - 1;
            for (; $j &gt;= 0; $j--) {
                if ($nums[$j] &gt; $value) {
                    $nums[$j+1] = $nums[$j];
                } else {
                    break;
                }
            }
            $nums[$j+1] = $value;
        }
    
        return $nums;
    }
    
    $nums = [4, 5, 6, 3, 2, 1];
    $nums = insertion_sort($nums);
    print_r($nums);
</code></pre></div><h1 id="性能分析">性能分析</h1>
<pre><code>插入排序需要两个嵌套的循环，时间复杂度是O(n2)；
没有额外的存储空间，是原地排序算法；
不涉及相等元素位置交换，是稳定的排序算法。
</code></pre>
<p>插入排序的时间复杂度和冒泡排序一样，也不是很理想，但是插入排序不涉及数据交换，从更细粒度来区分，性能要略优于冒泡排序。</p>

                
              </div>

              
                <span class="post-meta">
                  
                    #<a href="/tags/algorithms/">Algorithms</a>&nbsp;
                  
                </span>
              

            </article>
          
            <article class="post-preview">
              <a href="/post/algorithms/sort/algorithms-sort-bubblesort/">
                <h2 class="post-title">排序算法-冒泡排序(BubbleSort)</h2>

                
              </a>

              <p class="post-meta">
                发表于 map[Count:2019-08-07]
              </p>
              <div class="post-entry">
                
                  冒泡排序(BubbleSort) 常见基于选择的排序算法有冒泡排序、插入排序、选择排序、归并排序和快速排序，在选择排序算法的时候，通常会根据以下几个维度来考虑：
时间复杂度 空间复杂度（对内存空间的消耗） 算法的稳定性（如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变）  实现原理 冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求，如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。
光看定义有点抽象，用图来演示，假设待排序数字是 4、5、6、3、2、1，第一次排序的流程是这样的：
看这个图的时候要结合定义一起看，否则也比较懵逼，当然如果去 VisuAlgo 上看动态图的话就更形象了：https://visualgo.net/zh/sorting，经过 n 次冒泡，最终完成排序（所谓冒泡，以升序来看，就是每次把待排序序列中的最大值插到已排序序列的最前面，这个过程就像冒泡一样）：
示例代码
重要的是理解冒泡排序的原理，懂了原理就是把这个排序过程翻译成代码而已，以下是 PHP 代码实现的冒泡排序：
&lt;?php /** * 冒泡排序实现函数（PHP） * @param $nums * @return mixed */ function bubble_sort($nums) { if (count($nums) &lt;= 1) { return $nums; } for ($i = 0; $i &lt; count($nums); $i++) { $flag = false; for ($j = 0; $j &lt; count($nums) - $i - 1; $j++) { if ($nums[$j] &gt; $nums[$j+1]) { $temp = $nums[$j]; $nums[$j] = $nums[$j+1]; $nums[$j+1] = $temp; $flag = true; } } if (!
                  <a href="/post/algorithms/sort/algorithms-sort-bubblesort/" class="post-read-more">[阅读全文]</a>
                
              </div>

              
                <span class="post-meta">
                  
                    #<a href="/tags/algorithms/">Algorithms</a>&nbsp;
                  
                </span>
              

            </article>
          
            <article class="post-preview">
              <a href="/post/algorithms/sort/algorithms-sort-mergesort/">
                <h2 class="post-title">排序算法-归并排序(MergeSort)</h2>

                
              </a>

              <p class="post-meta">
                发表于 map[Count:2019-08-07]
              </p>
              <div class="post-entry">
                
                  实现原理 排序算法性能更好的排序算法，归并排序。
所谓归并排序，指的是如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。
归并排序使用了分治思想，分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。说到这里，可能你就能联想起我们之前讲到的一个编程技巧 —— 递归，没错，归并排序就是通过递归来实现的。这个递归的公式是每次都将传入的待排序数组一分为二，直到不能分割，然后将排序后序列合并，最终返回排序后的数组。
原理图如下所示：
由于涉及到递归，所以归并排序从理解上要比前面三个排序要困难一些，还是建议通过这个动态图帮助理解：https://visualgo.net/zh/sorting，在界面顶部选择归并排序，然后在左下角点击执行即可。
示例代码 &lt;?php function merge_sort($nums) { if (count($nums) &lt;= 1) { return $nums; } merge_sort_c($nums, 0, count($nums) - 1); return $nums; } function merge_sort_c(&amp;$nums, $p, $r) { if ($p &gt;= $r) { return; } $q = floor(($p + $r) / 2); merge_sort_c($nums, $p, $q); merge_sort_c($nums, $q + 1, $r); merge($nums, [&#39;start&#39; =&gt; $p, &#39;end&#39; =&gt; $q], [&#39;start&#39; =&gt; $q + 1, &#39;end&#39; =&gt; $r]); } function merge(&amp;$nums, $nums_p, $nums_q) { $temp = []; $i = $nums_p[&#39;start&#39;]; $j = $nums_q[&#39;start&#39;]; $k = 0; while ($i &lt;= $nums_p[&#39;end&#39;] &amp;&amp; $j &lt;= $nums_q[&#39;end&#39;]) { if ($nums[$i] &lt;= $nums[$j]) { $temp[$k++] = $nums[$i++]; } else { $temp[$k++] = $nums[$j++]; } } if ($i &lt;= $nums_p[&#39;end&#39;]) { for (; $i &lt;= $nums_p[&#39;end&#39;]; $i++) { $temp[$k++] = $nums[$i]; } } if ($j &lt;= $nums_q[&#39;end&#39;]) { for (; $j &lt;= $nums_q[&#39;end&#39;]; $j++) { $temp[$k++] = $nums[$j]; } } for ($x = 0; $x &lt; $k; $x++) { $nums[$nums_p[&#39;start&#39;] + $x] = $temp[$x]; } } $nums = [4, 5, 6, 3, 2, 1]; $nums = merge_sort($nums); print_r($nums); 性能分析 总结，归并排序不涉及相等元素位置交换，是稳定的排序算法，时间复杂度是 O(nlogn)，要优于冒泡排序和插入排序的 O(n2)，但是归并排序需要额外的空间存放排序数据，不是原地排序，最多需要和待排序数组同样大小的空间，所以空间复杂度是 O(n)。
                  <a href="/post/algorithms/sort/algorithms-sort-mergesort/" class="post-read-more">[阅读全文]</a>
                
              </div>

              
                <span class="post-meta">
                  
                    #<a href="/tags/algorithms/">Algorithms</a>&nbsp;
                  
                </span>
              

            </article>
          
            <article class="post-preview">
              <a href="/post/algorithms/sort/algorithms-sort-quicksort/">
                <h2 class="post-title">排序算法-快速排序(QuickSort)</h2>

                
              </a>

              <p class="post-meta">
                发表于 map[Count:2019-08-07]
              </p>
              <div class="post-entry">
                
                  实现原理 归并排序算法虽好，但是不是原地排序算法，需要消耗额外的内存空间，是常规排序里综合排名最高的排序算法：快速排序，江湖人称「快排」。
快排的核心思想是这样的：
如果要排序数组中下标从 p 到 r 之间的一组数据，选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。
遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。
图示如下：
根据分治、递归的处理思想，可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序了，而且可以看到不需要像归并排序那样做合并操作，也就不需要额外的内存空间，在算法复杂度和归并排序一样的情况下，有着更好的空间复杂度表现。
快速排序首先要找到分区点 pivot，一般我们会将数组最后一个元素或者第一个元素作为 pivot，比如我们以最后一个元素作为分区点，然后通过两个变量 i 和 j 作为下标来循环数组，当下标 j 对应数据小于 pivot 时，交换 i 和 j 对应数据，并且将 i 往前移动一位，否则 i 不动，下标 j 始终是往前移动的，j 到达终点后，将 pivot 与下标 i 对应数据交换，这样最终将 pivot 置于数组中间，[0&hellip;i-1] 区间的数据都比 pivot 小，[i+1&hellip;j] 之间的数据都比 pivot 大，我们以递归的方式处理该流程，最终整个数组都会变成有序的，对应的算法操作流程如下：
                  <a href="/post/algorithms/sort/algorithms-sort-quicksort/" class="post-read-more">[阅读全文]</a>
                
              </div>

              
                <span class="post-meta">
                  
                    #<a href="/tags/algorithms/">Algorithms</a>&nbsp;
                  
                </span>
              

            </article>
          
            <article class="post-preview">
              <a href="/post/algorithms/datastructures/algorithms-datastructures-recursion/">
                <h2 class="post-title">数据结构-递归(Recursion)</h2>

                
              </a>

              <p class="post-meta">
                发表于 map[Count:2019-08-06]
              </p>
              <div class="post-entry">
                
                  递归(Recursion) 递归算不上任何数据结构和算法，但确实是一种很重要的编程技巧，很多算法也会用到递归来实现，比如归并排序、快速排序、二分查找等。
递归，简单来讲就是在函数定义中调用函数自身，从之前学习数学解题经验来讲，就是将一个大的问题拆分成多个小问题，逐一击破后最后归并结果。判断一个问题是否可以通过递归来解决，主要看它是否满足以下三个条件：
 一个问题的解可以分解为几个子问题的解 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样 存在递归终止条件  递归一定要有终止条件，否则会导致函数被无限调用最终致使内存溢出。
通过以上分析，可以整理出递归代码的编写思路：写出递归公式，找到终止条件。有句话叫做「人理解迭代，神理解递归」，说的就是递归代码可读性不好，理论上看，递归代码都是可以转化成迭代实现的，但是递归代码更简洁，更显逼格，在通过递归实现代码的时候，切忌试图通过人脑去分解每个步骤，那样会把自己搞晕的，这种重复迭代的事情交给计算机去做，要做的就是抽象出规律，写递归公式，找终止条件，再把它们转化为递归代码，就完事了。
说了这么多，最后通过一个案例来帮助理解和实际运用。递归的应用案例很多，比如经典的汉诺塔、斐波那契数列等，以斐波那契数列来演示下递归代码的编写，斐波那契数列是这样一组数列：0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, …(可以去网上搜一下了解下这个数列的现实由来），求第n个数列的值。
按照前面列出的递归问题解题思路，首先抽象出这组数列的一般规律，将其整理成递归公式，会得出如下结论（索引从0开始，即第零项）：
F0 = 0 F1 = 1 ... F(n) = F(n-1) + F(n-2) 这样，同时有了终止条件和递归公式，接下来，就是将其转化为递归代码了：
&lt;?php /** * 通过递归实现斐波那契数列 */ function fibonacci($n) { if ($n == 0) { return 0; } if ($n == 1) { return 1; } return fibonacci($n - 2) + fibonacci($n - 1); } print fibonacci(5); # 5 print fibonacci(8); # 21 通过递归，用非常简洁的代码就实现了复杂的斐波那契数列的求解，如果要用迭代来实现这个逻辑，不定要写多少代码呢。
                  <a href="/post/algorithms/datastructures/algorithms-datastructures-recursion/" class="post-read-more">[阅读全文]</a>
                
              </div>

              
                <span class="post-meta">
                  
                    #<a href="/tags/algorithms/">Algorithms</a>&nbsp;
                  
                </span>
              

            </article>
          
            <article class="post-preview">
              <a href="/post/algorithms/datastructures/algorithms-datastructures-queue/">
                <h2 class="post-title">数据结构-队列(Queue)</h2>

                
              </a>

              <p class="post-meta">
                发表于 map[Count:2019-08-05]
              </p>
              <div class="post-entry">
                
                  队列(Queue) 数据结构 —— 队列，和栈一样，队列也是一中特殊的线性表结构，只不过队列是在一端插入，另一端删除，就跟平常排队一样的道理，从队尾入队，在队头出去，所以队列的特性是先入先出（FIFO），允许插入的一端叫队尾，允许删除的一端叫队头。
一张图可以形象的体现两者的差别：
和栈一样，队列也可以通过数组和链表实现，通过数组实现的叫顺序队列，通过链表实现的叫做链式队列，栈只需要一个栈顶指针就可以了，因为只允许在栈顶插入删除，但是队列需要两个指针，一个指向队头，一个指向队尾。先来看通过 PHP 数组实现的顺序队列代码：
&lt;?php /** * 通过 PHP 数组实现的队列 */ class SimpleQueue { private $_queue = []; private $_size = 0; public function __construct($size = 10) { $this-&gt;_size = $size; } // 入队 public function enqueue($value) { if (count($this-&gt;_queue) &gt; $this-&gt;_size) { return false; } array_push($this-&gt;_queue, $value); } // 出队 public function dequeue() { if (count($this-&gt;_queue) == 0) { return false; } return array_shift($this-&gt;_queue); } public function size() { return count($this-&gt;_queue); } } $queue = new SimpleQueue(5); $queue-&gt;enqueue(1); $queue-&gt;enqueue(3); $queue-&gt;enqueue(5); var_dump($queue-&gt;dequeue()); # 1 var_dump($queue-&gt;size()); # 2 通过数组实现的顺序队列有一个问题，就是随着队列元素的插入和删除，队尾指针和队头指针不断后移，而导致队尾指针指向末尾无法插入数据，这时候有可能队列头部还是有剩余空间的，如下图所示：
                  <a href="/post/algorithms/datastructures/algorithms-datastructures-queue/" class="post-read-more">[阅读全文]</a>
                
              </div>

              
                <span class="post-meta">
                  
                    #<a href="/tags/algorithms/">Algorithms</a>&nbsp;
                  
                </span>
              

            </article>
          
        </div>
        
          <ul class="pager main-pager">
            
              <li class="previous">
                <a href="page/4">&larr; 上一页</a>
              </li>
            
            
              <li class="next">
                <a href="page/6">下一页 &rarr;</a>
              </li>
            
          </ul>
        
      </div>
    </div>
  </div>

    <footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
          <img src="/img/wechatmp.png" alt="k8s技术圈">
          
          <li>
            <a href="mailto:icnych@gmail.com" title="Email me">
              <span class="fa-stack fa-lg">
                <i class="fa fa-circle fa-stack-2x"></i>
                <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
          <li>
            <a href="https://github.com/cnych" title="GitHub">
              <span class="fa-stack fa-lg">
                <i class="fa fa-circle fa-stack-2x"></i>
                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
          <li>
            <a href="https://weibo.com/cnych" title="微博">
              <span class="fa-stack fa-lg">
                <i class="fa fa-circle fa-stack-2x"></i>
                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
          <li>
            <a href="https://instagram.com/cnych" title="Instagram">
              <span class="fa-stack fa-lg">
                <i class="fa fa-circle fa-stack-2x"></i>
                <i class="fa fa-instagram fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
          
          <li>
            <a href="/%20index.xml" title="RSS">
              <span class="fa-stack fa-lg">
                <i class="fa fa-circle fa-stack-2x"></i>
                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
        </ul>
        <p class="credits copyright text-muted">
          
          
          <a href="/">WoolfBreathe</a>
          
          

          &nbsp;&bull;&nbsp;
          2021
        </p>
        
        
        <p class="credits theme-by text-muted">
          <a href="http://gohugo.io">Hugo v0.68.3</a> powered &nbsp;&bull;&nbsp; Theme by <a
            href="https://github.com/rootsongjc/beautifulhugo">Beautiful Hugo</a> Adapted To <a
            href="https://github.com/cnych/qikqiak.com">qikqiak-blog</a>
          
        </p>
      </div>
    </div>
  </div>
</footer>

<script src='/js/bundle.min.b7dfdd821c9f407aafd1909c145d179393173d1476e753e70269be48968a707d.js' integrity='sha256-t9/dghyfQHqv0ZCcFF0Xk5MXPRR251PnAmm&#43;SJaKcH0='></script>








  </body>
</html>

